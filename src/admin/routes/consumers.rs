use std::sync::Arc;
use anyhow::Result;
use hyper::{Body, Request, Response, StatusCode};
use tracing::{debug, error, info};
use serde_json::Value;
use bcrypt::{hash, DEFAULT_COST};

use crate::admin::AdminApiState;
use crate::config::data_model::Consumer;
use crate::modes::OperationMode;
use crate::admin::pagination::{PaginationQuery, create_paginated_response};

/// Handler for GET /consumers endpoint - lists all consumers
pub async fn list_consumers(req: Request<Body>, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Extract pagination parameters
    let pagination = PaginationQuery::from_request(&req);
    
    // Get the current configuration
    let config = state.shared_config.read().await;
    
    // Apply pagination to the consumers
    let (paginated_consumers, pagination_meta) = pagination.paginate(&config.consumers);
    
    // Create the paginated response
    let response = create_paginated_response(paginated_consumers, pagination_meta);
    
    // Serialize to JSON
    let json = serde_json::to_string(&response)?;
    
    // Return the response
    Ok(Response::builder()
        .status(StatusCode::OK)
        .header("Content-Type", "application/json")
        .body(Body::from(json))
        .unwrap())
}

/// Handler for POST /consumers endpoint - creates a new consumer
pub async fn create_consumer(req: Request<Body>, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Check operation mode
    if state.operation_mode == OperationMode::File {
        return Ok(Response::builder()
            .status(StatusCode::CONFLICT)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Cannot modify config — currently running in File Mode"}"#))
            .unwrap());
    }
    
    // Read the request body
    let body_bytes = hyper::body::to_bytes(req.into_body()).await?;
    
    // Deserialize the consumer from JSON
    let mut consumer = serde_json::from_slice::<Consumer>(&body_bytes)
        .map_err(|e| anyhow::anyhow!("Invalid consumer data: {}", e))?;
    
    // Verify username uniqueness
    {
        let config = state.shared_config.read().await;
        for existing_consumer in &config.consumers {
            if existing_consumer.username == consumer.username {
                return Ok(Response::builder()
                    .status(StatusCode::CONFLICT)
                    .header("Content-Type", "application/json")
                    .body(Body::from(format!(
                        r#"{{"error":"A consumer with username '{}' already exists"}}"#,
                        consumer.username
                    )))
                    .unwrap());
            }
        }
    }
    
    // Set timestamps
    let now = chrono::Utc::now();
    consumer.created_at = now;
    consumer.updated_at = now;
    
    // Create the consumer in the database
    if let Some(db) = &state.db_client {
        match db.create_consumer(&consumer).await {
            Ok(id) => {
                // Use the ID generated by the database
                consumer.id = id;
                
                // Return the created consumer
                let json = serde_json::to_string(&consumer)?;
                
                Ok(Response::builder()
                    .status(StatusCode::CREATED)
                    .header("Content-Type", "application/json")
                    .body(Body::from(json))
                    .unwrap())
            },
            Err(e) => {
                error!("Failed to create consumer in database: {}", e);
                
                Ok(Response::builder()
                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Content-Type", "application/json")
                    .body(Body::from(format!(r#"{{"error":"Failed to create consumer: {}"}}"#, e)))
                    .unwrap())
            }
        }
    } else {
        // No database client available
        Ok(Response::builder()
            .status(StatusCode::SERVICE_UNAVAILABLE)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Database is unavailable"}"#))
            .unwrap())
    }
}

/// Handler for GET /consumers/{id} endpoint - gets a specific consumer
pub async fn get_consumer(consumer_id: &str, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Get the consumer from the database by ID
    let consumer = {
        // First try looking it up from in-memory configuration
        let config = state.shared_config.read().await;
        let consumer = config.consumers.iter().find(|c| c.id == consumer_id).cloned();
        
        // If not found in memory and we have a database client, try to fetch it from the database
        if consumer.is_none() && state.db_client.is_some() {
            debug!("Consumer not found in memory, trying to fetch from database: {}", consumer_id);
            let db = state.db_client.as_ref().unwrap();
            
            // Query the database for the consumer with the given ID
            match db.get_consumer_by_id(consumer_id).await {
                Ok(db_consumer) => {
                    debug!("Successfully retrieved consumer from database: {}", consumer_id);
                    Some(db_consumer)
                },
                Err(e) => {
                    debug!("Failed to retrieve consumer from database: {}", e);
                    None
                }
            }
        } else {
            consumer
        }
    };
    
    // If no consumer was found, return 404
    let consumer = consumer.ok_or_else(|| anyhow::anyhow!("Consumer not found"))?;
    
    // Serialize the consumer to JSON
    let json = serde_json::to_string(&consumer)?;
    
    // Return the response
    Ok(Response::builder()
        .status(StatusCode::OK)
        .header("Content-Type", "application/json")
        .body(Body::from(json))
        .unwrap())
}

/// Handler for PUT /consumers/{id} endpoint - updates a specific consumer
pub async fn update_consumer(consumer_id: &str, req: Request<Body>, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Check operation mode
    if state.operation_mode == OperationMode::File {
        return Ok(Response::builder()
            .status(StatusCode::CONFLICT)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Cannot modify config — currently running in File Mode"}"#))
            .unwrap());
    }
    
    // Read the request body
    let body_bytes = hyper::body::to_bytes(req.into_body()).await?;
    
    // Deserialize the consumer from JSON
    let mut updated_consumer = serde_json::from_slice::<Consumer>(&body_bytes)
        .map_err(|e| anyhow::anyhow!("Invalid consumer data: {}", e))?;
    
    // Ensure the ID in the path matches the ID in the body
    if updated_consumer.id != consumer_id {
        return Ok(Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Consumer ID in the path does not match the ID in the request body"}"#))
            .unwrap());
    }
    
    // Check if the consumer exists and username is unique
    {
        let config = state.shared_config.read().await;
        
        // Check if the consumer exists
        let exists = config.consumers.iter().any(|c| c.id == consumer_id);
        if !exists {
            return Ok(Response::builder()
                .status(StatusCode::NOT_FOUND)
                .header("Content-Type", "application/json")
                .body(Body::from(r#"{"error":"Consumer not found"}"#))
                .unwrap());
        }
        
        // Check username uniqueness (only if changed)
        for existing_consumer in &config.consumers {
            if existing_consumer.username == updated_consumer.username && existing_consumer.id != consumer_id {
                return Ok(Response::builder()
                    .status(StatusCode::CONFLICT)
                    .header("Content-Type", "application/json")
                    .body(Body::from(format!(
                        r#"{{"error":"A consumer with username '{}' already exists"}}"#,
                        updated_consumer.username
                    )))
                    .unwrap());
            }
        }
    }
    
    // Update the timestamp
    updated_consumer.updated_at = chrono::Utc::now();
    
    // Update the consumer in the database
    if let Some(db) = &state.db_client {
        match db.update_consumer(&updated_consumer).await {
            Ok(_) => {
                // Serialize the updated consumer to JSON
                let json = serde_json::to_string(&updated_consumer)?;
                
                // Return the response
                Ok(Response::builder()
                    .status(StatusCode::OK)
                    .header("Content-Type", "application/json")
                    .body(Body::from(json))
                    .unwrap())
            },
            Err(e) => {
                error!("Failed to update consumer in database: {}", e);
                
                Ok(Response::builder()
                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Content-Type", "application/json")
                    .body(Body::from(format!(r#"{{"error":"Failed to update consumer: {}"}}"#, e)))
                    .unwrap())
            }
        }
    } else {
        // No database client available
        Ok(Response::builder()
            .status(StatusCode::SERVICE_UNAVAILABLE)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Database is unavailable"}"#))
            .unwrap())
    }
}

/// Handler for DELETE /consumers/{id} endpoint - deletes a specific consumer
pub async fn delete_consumer(consumer_id: &str, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Check operation mode
    if state.operation_mode == OperationMode::File {
        return Ok(Response::builder()
            .status(StatusCode::CONFLICT)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Cannot modify config — currently running in File Mode"}"#))
            .unwrap());
    }
    
    // Check if the consumer exists
    {
        let config = state.shared_config.read().await;
        
        if !config.consumers.iter().any(|c| c.id == consumer_id) {
            return Ok(Response::builder()
                .status(StatusCode::NOT_FOUND)
                .header("Content-Type", "application/json")
                .body(Body::from(r#"{"error":"Consumer not found"}"#))
                .unwrap());
        }
    }
    
    // Delete the consumer from the database
    if let Some(db) = &state.db_client {
        match db.delete_consumer(consumer_id).await {
            Ok(_) => {
                // Return the response
                Ok(Response::builder()
                    .status(StatusCode::NO_CONTENT)
                    .body(Body::empty())
                    .unwrap())
            },
            Err(e) => {
                error!("Failed to delete consumer from database: {}", e);
                
                Ok(Response::builder()
                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Content-Type", "application/json")
                    .body(Body::from(format!(r#"{{"error":"Failed to delete consumer: {}"}}"#, e)))
                    .unwrap())
            }
        }
    } else {
        // No database client available
        Ok(Response::builder()
            .status(StatusCode::SERVICE_UNAVAILABLE)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Database is unavailable"}"#))
            .unwrap())
    }
}

/// Handler for GET /consumers/{id}/credentials/{credential_type} endpoint - gets specific credentials
pub async fn get_consumer_credentials(consumer_id: &str, credential_type: &str, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Get the current configuration
    let config = state.shared_config.read().await;
    
    // Find the consumer with the specified ID
    let consumer = config.consumers
        .iter()
        .find(|c| c.id == consumer_id)
        .ok_or_else(|| anyhow::anyhow!("Consumer not found"))?;
    
    // Get the specified credential
    let credential = consumer.credentials.get(credential_type)
        .ok_or_else(|| anyhow::anyhow!("Credential type not found for this consumer"))?;
    
    // Serialize the credential to JSON
    let json = serde_json::to_string(credential)?;
    
    // Return the response
    Ok(Response::builder()
        .status(StatusCode::OK)
        .header("Content-Type", "application/json")
        .body(Body::from(json))
        .unwrap())
}

/// Handler for PUT /consumers/{id}/credentials/{credential_type} endpoint - updates specific credentials
pub async fn update_consumer_credentials(consumer_id: &str, credential_type: &str, req: Request<Body>, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Check operation mode
    if state.operation_mode == OperationMode::File {
        return Ok(Response::builder()
            .status(StatusCode::CONFLICT)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Cannot modify config — currently running in File Mode"}"#))
            .unwrap());
    }
    
    // Read the request body
    let body_bytes = hyper::body::to_bytes(req.into_body()).await?;
    
    // Deserialize the credential from JSON
    let mut credential = serde_json::from_slice::<Value>(&body_bytes)
        .map_err(|e| anyhow::anyhow!("Invalid credential data: {}", e))?;
    
    // Hash the credential if necessary
    hash_credential(credential_type, &mut credential)?;
    
    // Get the current consumer
    let mut consumer = {
        let config = state.shared_config.read().await;
        
        // Find the consumer with the specified ID
        let consumer = config.consumers
            .iter()
            .find(|c| c.id == consumer_id)
            .cloned()
            .ok_or_else(|| anyhow::anyhow!("Consumer not found"))?;
        
        consumer
    };
    
    // Update the credential in the consumer object
    consumer.credentials.insert(credential_type.to_string(), credential.clone());
    consumer.updated_at = chrono::Utc::now();
    
    // Update the consumer in the database
    if let Some(db) = &state.db_client {
        match db.update_consumer(&consumer).await {
            Ok(_) => {
                // Return the response
                Ok(Response::builder()
                    .status(StatusCode::OK)
                    .header("Content-Type", "application/json")
                    .body(Body::from(serde_json::to_string(&credential)?))
                    .unwrap())
            },
            Err(e) => {
                error!("Failed to update consumer credentials in database: {}", e);
                
                Ok(Response::builder()
                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Content-Type", "application/json")
                    .body(Body::from(format!(r#"{{"error":"Failed to update consumer credentials: {}"}}"#, e)))
                    .unwrap())
            }
        }
    } else {
        // No database client available
        Ok(Response::builder()
            .status(StatusCode::SERVICE_UNAVAILABLE)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Database is unavailable"}"#))
            .unwrap())
    }
}

/// Handler for DELETE /consumers/{id}/credentials/{credential_type} endpoint - deletes specific credentials
pub async fn delete_consumer_credentials(consumer_id: &str, credential_type: &str, state: Arc<AdminApiState>) -> Result<Response<Body>> {
    // Check operation mode
    if state.operation_mode == OperationMode::File {
        return Ok(Response::builder()
            .status(StatusCode::CONFLICT)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Cannot modify config — currently running in File Mode"}"#))
            .unwrap());
    }
    
    // Get the current consumer
    let mut consumer = {
        let config = state.shared_config.read().await;
        
        // Find the consumer with the specified ID
        let consumer = config.consumers
            .iter()
            .find(|c| c.id == consumer_id)
            .cloned()
            .ok_or_else(|| anyhow::anyhow!("Consumer not found"))?;
        
        consumer
    };
    
    // Check if the credential exists
    if !consumer.credentials.contains_key(credential_type) {
        return Ok(Response::builder()
            .status(StatusCode::NOT_FOUND)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Credential type not found for this consumer"}"#))
            .unwrap());
    }
    
    // Remove the credential
    consumer.credentials.remove(credential_type);
    consumer.updated_at = chrono::Utc::now();
    
    // Update the consumer in the database
    if let Some(db) = &state.db_client {
        match db.update_consumer(&consumer).await {
            Ok(_) => {
                // Return the response
                Ok(Response::builder()
                    .status(StatusCode::NO_CONTENT)
                    .body(Body::empty())
                    .unwrap())
            },
            Err(e) => {
                error!("Failed to delete consumer credentials from database: {}", e);
                
                Ok(Response::builder()
                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Content-Type", "application/json")
                    .body(Body::from(format!(r#"{{"error":"Failed to delete consumer credentials: {}"}}"#, e)))
                    .unwrap())
            }
        }
    } else {
        // No database client available
        Ok(Response::builder()
            .status(StatusCode::SERVICE_UNAVAILABLE)
            .header("Content-Type", "application/json")
            .body(Body::from(r#"{"error":"Database is unavailable"}"#))
            .unwrap())
    }
}

/// Hash all sensitive credential values in a credentials map
pub async fn hash_sensitive_credentials(credentials: &mut std::collections::HashMap<String, Value>) -> Result<()> {
    for (cred_type, cred_value) in credentials.iter_mut() {
        hash_credential(cred_type, cred_value)?;
    }
    
    Ok(())
}

/// Hash a credential value based on its type
fn hash_credential(cred_type: &str, cred_value: &mut Value) -> Result<()> {
    match cred_type {
        "key-auth" => {
            // Key authentication credentials
            if let Some(key) = cred_value.get_mut("key").and_then(|v| v.as_str()) {
                // Only hash if it's not already hashed
                if !key.starts_with("$2y$") && !key.starts_with("$2a$") && !key.starts_with("$2b$") {
                    let hashed = hash(key, DEFAULT_COST)?;
                    *cred_value.get_mut("key").unwrap() = Value::String(hashed);
                }
            }
        },
        "basic-auth" => {
            // Basic authentication credentials
            if let Some(password) = cred_value.get_mut("password").and_then(|v| v.as_str()) {
                // Only hash if it's not already hashed
                if !password.starts_with("$2y$") && !password.starts_with("$2a$") && !password.starts_with("$2b$") {
                    let hashed = hash(password, DEFAULT_COST)?;
                    *cred_value.get_mut("password").unwrap() = Value::String(hashed);
                }
            }
        },
        "jwt" => {
            // JWT credentials don't need hashing
        },
        "oauth2" => {
            // OAuth2 credentials (client secret should be hashed)
            if let Some(secret) = cred_value.get_mut("client_secret").and_then(|v| v.as_str()) {
                // Only hash if it's not already hashed
                if !secret.starts_with("$2y$") && !secret.starts_with("$2a$") && !secret.starts_with("$2b$") {
                    let hashed = hash(secret, DEFAULT_COST)?;
                    *cred_value.get_mut("client_secret").unwrap() = Value::String(hashed);
                }
            }
        },
        // Add other credential types as needed
        _ => {}
    }
    
    Ok(())
}
